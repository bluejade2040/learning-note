#!/usr/bin/env python
# coding: utf-8

# # HeapSort程式碼和文字說明

# Heapsort藉由最大值上升到tree的頂點，然後移除到list最後一項來完成排序。
# heapsort()：將root為最大值的tree轉換成「由小到大」排好序的矩陣。把root丟到矩陣最後。
# buildheap()：對所有子結點進行heapify()。
# heapify()：「由上而下」，逐一檢查每個子根項，把最大值lar擺進子root。

# In[ ]:


def heapsort(list): #提出最大值到最後一項
    buildheap(list)
    for i in range(2,n):
        list[0],list[i] = list[i],list[0] #最大值提出
        n = n-1  #n變成目前還沒被提出的數字個數
        heapify(list,lar,n)
        
def buildheap(list):
    n = len(list)
    for i in range(n//2): #n//2表示需要處理的root數量
        heapify(list,i,n)
def heapify(list,i,n): #建立最大值 
    
    left = i*2+1
    right = i*2+2
    
    if left <= n and list[left] > list[i]:
        lar = left
    else:
        lar = i
    if right <= n and list[right] > list[lar]:
        lar = right
    if lar != i:  #判斷子根項是否最大，不是最大就替換掉  
        list[i],list[lar] = list[lar],list[i]
        heapify(list,lar,n)  #有替換就要再跑一次


# In[24]:


list = [5,3,8,1,9,0,8,11,13,6,7,10]
heapsort(list)


# 微調一下迴圈次數~

# In[44]:


def heapsort(list): #提出最大值到最後一項
    buildheap(list)
    for i in range(n):
        list[0],list[i] = list[i],list[0] #最大值提出
        n = n-1  #n變成目前還沒被提出的數字個數
        heapify(list,lar,n)
        
def buildheap(list):
    n = len(list)
    for i in range(n//2): #n//2表示需要處理的root數量
        heapify(list,i,n)
def heapify(list,i,n): #建立最大值 
    
    left = i*2+1
    right = i*2
    
    if left <= n and list[left] > list[i]:
        lar = left
    else:
        lar = i
    if right <= n and list[right] > list[lar]:
        lar = right
    if lar != i:  #判斷子根項是否最大，不是最大就替換掉  
        list[i],list[lar] = list[lar],list[i]
        heapify(list,lar,n)  #有替換就要再跑一次     


# In[45]:


list = [5,3,8,1,9,0,8,11,13,6,7,10]
heapsort(list)


# UnboundLocalError: local variable 'n' referenced before assignment
# 表示內外層有相同的variable但不同的賦值所以出錯。
# 修改明確一點~

# In[2]:


def heapsort(list): #提出最大值到最後一項
    buildheap(list)
    n = len(list)
    for i in range(len(list)):
        list[0],list[i] = list[i],list[0] #最大值提出
        n = n-1  #n變成目前還沒被提出的數字個數
        heapify(list,n,i)
        
def buildheap(list):
    n = len(list)
    for i in range(n//2): #n//2表示需要處理的root數量
        heapify(list,i,n)  #創造出最大值在root的heap
        
def heapify(list,i,n): #建立子root為最大值 
    
    left = i*2+1
    right = i*2
    
    if left < n and list[left] > list[i]:
        lar = left
    else:
        lar = i
    if right < n and list[right] > list[lar]:
        lar = right
    if lar != i:  #判斷子根項是否最大，不是最大就替換掉  
        list[i],list[lar] = list[lar],list[i]
        heapify(list,lar,n)  #有替換就要再跑一次


# In[12]:


for i in range(13//2): ##實驗一下for迴圈~
    print(1)


# In[8]:


list = [5,3,8,1,9,0,8,6,7,10]
heapsort(list)
print(list)


# In[ ]:


在for迴圈的地方邏輯次數有錯，再換個寫法試試。
明確訂定開始值、結束值跟公差。


# In[78]:


def heapsort(list): #提出最大值到最後一項
    buildheap(list)
    n = len(list)
    for i in range(n-1,0,-1):
        list[0],list[i] = list[i],list[0] #最大值提出
        heapify(list,0,i)
        
def buildheap(list):
    n = len(list)
    for i in range(n,-1,-1):  #i從n到-1，每跑一次-1
        heapify(list,i,n)  #創造出最大值在root的heap
        
def heapify(list,i,n): #建立子root為最大值 
    
    left = i*2+1
    right = i*2
    
    if left < n and list[left] > list[i]:
        lar = left
    else:
        lar = i
    if right < n and list[right] > list[lar]:
        lar = right
    if lar != i:  #判斷子根項是否最大，不是最大就替換掉  
        list[i],list[lar] = list[lar],list[i]
        heapify(list,lar,n)  #有替換就要再跑一次


# In[84]:


list = [3,1,0,8,6,7,10,15,9,13,18,14]
heapsort(list)
print(list)


# 參考資料:
#     https://www.cc.gatech.edu/classes/cs3158_98_fall/heapsort.html
#     https://stackoverflow.com/questions/43700267/max-heapify-pseudocode
#     https://youtu.be/MtQL_ll5KhQ
